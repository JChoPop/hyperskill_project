// By HJC 2021-11-21
// 5x5 Futoshiki (Inequality/Unequal Puzzle)
//
val input = """
			|1-3>2-5-4|
            |- - - - -|
            |3-5-1-4-2|
            |v v ^ - -|
            |2-4>3-1-5|
            |- - - ^ -|
            |4-0-0-0-0|
            |^ - - - v|
            |5-0-0-0-0""".trimMargin()
//
fun isEven(num: Int) = num % 2 == 0
val num = mutableListOf<Int>()
val sig = mutableMapOf<Int, MutableSet<Int>>()
//
fun main() {
	//     println(input)
    stringify(input)
    println("num: $num")
    println("sig: $sig")
    // num: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    // sig: {1=[2], 5=[10], 6=[11], 12=[7], 11=[12], 18=[13], 20=[15], 19=[24]}
    
    var sol = num.toMutableList()

    solve(sol, 0, 1)
    //     printBoard()
}
//
fun stringify(input: String) {
    fun setOrAddSign(big: Int, small: Int) { if (sig[big].isNullOrEmpty()) sig[big] = mutableSetOf(small) else sig[big]!!.add(small) }
    
    val temp = input.split("|\n")
    println(temp)		// [0-0>0-0-0, - - - - -, 0-0-0-0-0, v v ^ - -, 0-0>0-0-0, - - - ^ -, 4-0-0-0-0, ^ - - - v, 0-0-0-0-0]
    
    for (i in 0..8) {
        jloop@ for (j in 0..8) {
            when (val want = temp[i][j].digitToIntOrNull() ?: temp[i][j]) {
                ' ', '-' -> continue@jloop
                is Int -> num.add(want)
                is Char -> {
                    val (big, small) = when (want) {	// key is always greater than value
                        '>' -> Pair(num.lastIndex, num.count())
                        '<' -> Pair(num.count(), num.lastIndex)
                        'v' -> Pair(num.count() + j/2 - 5, num.count() + j/2)
                        '^' -> Pair(num.count() + j/2, num.count() + j/2 - 5)
                        else -> throw Exception("Invalid Inequality Symbol (e.g: uppercase V should be lowercase v)")
                        }
                	setOrAddSign(big, small)
                }
            }
        }
    }
}
//
fun solve(sol: MutableList<Int>, tempind: Int, tempdir: Int, ) {
    //: output new num to eventually printBoard{
	var (ind, dir) = Pair(tempind, tempdir)
    if (ind == sol.count()) return
    while (tryAgain(ind, sol)) {
        when {
            sol[ind] != 0 && sol[ind] == num[ind] -> {}

            dir == -1 -> if (ind % 5 == 4 || ind >= 20 || sol[ind] == 5) sol[ind] = 0
                            else { sol[ind] += 1
                                dir = 1 }

            dir == 1 -> when {
                            sol[ind] == 5 -> { sol[ind] = 0
                                dir = -1 }
                            ind % 5 == 4 -> sol[ind] = 15 - sol.slice((ind - 4)..ind).sum()
                            ind >= 20 -> sol[ind] = 15 - sol.slice((ind % 5)..ind step 5).sum()
                            else -> sol[ind] += 1
                        }
        }
    }
    ind += dir
    println("ind: $ind, dir: $dir\nsol: $sol")
    solve(sol, ind, dir)
//     }
// 			need conditions for completion/no solution
}
//
// num: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0]
// sig: {1=[2], 5=[10], 6=[11], 12=[7], 11=[12], 18=[13], 20=[15], 19=[24]}
//
fun tryAgain(ind: Int, sol: MutableList<Int>, ): Boolean {
    val noDup = sol.slice((0..(ind - 1)).filter { it % 5 == ind % 5 || it / 5 == ind / 5 })
//     println("noDup: $noDup")
	//
    val signPairs = mutableSetOf<Pair<Int, Int>>()
    if (ind > 4) signPairs.addAll(setOf(Pair(ind, ind - 5), Pair(ind - 5, ind)))
    if (ind % 5 > 0) signPairs.addAll(setOf(Pair(ind, ind - 1), Pair(ind - 1, ind)))
    signPairs.reversed().forEach() { (k, v) -> if (!(sig[k]?.contains(v) ?: false)) signPairs -= Pair(k,v) }
    //
    return noDup.contains(sol[ind]) || sol[ind] == 0 || signPairs.any { (G, s) -> sol[G] < sol[s] }
}
//
fun printBoard() {
    
}
//
//
// Solution:
//	13254
//	35142
//	24315
//	41523
//	52431
//
//
//
//
//
//
//
